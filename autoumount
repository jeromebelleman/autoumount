#! /usr/bin/env python

'''
Automatically umount filesystem after a period of inactivity
'''

import sys
import os
import signal
import argparse
import subprocess
import logging
import pyinotify
import psutil

NORMAL = pyinotify.IN_ACCESS | pyinotify.IN_ATTRIB
CREATE = pyinotify.IN_CREATE

class EventHandler(pyinotify.ProcessEvent):
    '''
    Reset timer on filesystem activity
    '''

    def __init__(self, manager, mountpoint, timeout):
        '''
        Set timeout
        '''

        super(EventHandler, self).__init__()

        self.manager = manager
        self.mountpoint = mountpoint
        self.timeout = timeout

    def process_IN_ACCESS(self, _): # pylint: disable=invalid-name
        '''
        Reset timer on accesses
        '''

        signal.alarm(self.timeout)

    def process_IN_ATTRIB(self, _): # pylint: disable=invalid-name
        '''
        Reset timer on attribute changes
        '''

        signal.alarm(self.timeout)

    def process_IN_CREATE(self, event): # pylint: disable=invalid-name
        '''
        Watch new mountpoint
        '''

        if event.pathname == self.mountpoint:
            logging.debug("Removing watch on %s", event.path)
            self.manager.rm_watch(event.wd)

            logging.debug("Adding watch on %s", self.mountpoint)
            self.manager.add_watch(self.mountpoint, NORMAL)

            logging.debug("Setting up %ds timeout", self.timeout)
            signal.alarm(self.timeout)


def killall(mountpoint):
    '''
    Kill all processes keeping a filesystem busy
    '''

    for proc in psutil.process_iter():
        try:
            if proc.cwd().startswith(mountpoint):
                logging.debug("Killing %s", ' '.join(proc.cmdline()))
                proc.kill()
                continue
            for fle in proc.open_files():
                if fle[0].startswith(mountpoint):
                    logging.debug("Killing %s", ' '.join(proc.cmdline()))
                    proc.kill()
                    continue
        except psutil.AccessDenied:
            pass


def main():
    '''
    Main loop
    '''

    # Parse arguments
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument('mountpoint')
    parser.add_argument('timeout', type=int)
    parser.add_argument('command')
    parser.add_argument('--debug', action='store_true',
                        help="print debug information")
    args = parser.parse_args()

    # Set up logging
    logging.basicConfig(level=logging.DEBUG if args.debug else logging.INFO,
                        format='%(asctime)s %(levelname)s %(message)s',
                        datefmt='%Y-%m-%d %H:%M')

    # Normalise mountpoint
    mountpoint = os.path.abspath(args.mountpoint)
    dirname = os.path.dirname(mountpoint)

    # Initialise watches dictionary for umount function to see
    watches = {}

    # Signal handler
    def umount(signum, frame): # pylint: disable=unused-argument
        '''
        Unmount after killing processes if needs be
        '''

        # Kill processes
        killall(mountpoint)

        # Unmount filesystem
        logging.info("Running %s %s", args.command, mountpoint)
        subprocess.call('%s %s' % (args.command, mountpoint), shell=True)

        # Remove watches on mountpoint (which may be removed by themselves)
        for watch in watches:
            try:
                manager.rm_watch(watches[watch], quiet=False)
            except pyinotify.WatchManagerError:
                continue
            logging.debug("Removed watch on %s", watch)

        # Add watch on parent directory
        logging.debug("Adding watch on %s", dirname)
        manager.add_watch(dirname, CREATE, quiet=False)

    # Set up inotify and alarms
    logging.debug("Setting up inotify")
    manager = pyinotify.WatchManager()
    handler = EventHandler(manager, mountpoint, args.timeout)
    notifier = pyinotify.Notifier(manager, handler)

    signal.signal(signal.SIGALRM, umount)

    try:
        logging.debug("Adding watch on %s", mountpoint)
        watches = manager.add_watch(mountpoint, NORMAL, rec=True, quiet=False)

        logging.debug("Setting up %ds timeout", args.timeout)
        signal.alarm(args.timeout)
    except pyinotify.WatchManagerError, exc:
        logging.debug(exc)
        logging.debug("Adding watch on %s, then", dirname)
        watches = manager.add_watch(dirname, CREATE, quiet=False)

    notifier.loop()


if __name__ == '__main__':
    sys.exit(main())
